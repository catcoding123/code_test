# LeetCode 进度追踪模板

## 📊 整体进度统计

### 完成情况总览
- **总题目数**: 8/100
- **熟练掌握** 🔥: 8 题
- **基本理解** ⚡: 0 题  
- **需要复习** ❌: 0 题

### 按难度统计
- **Easy**: 1/45
- **Medium**: 4/70
- **Hard**: 3/30

### 按主题统计
- [x] 数组与双指针 (2/10) 
- [ ] 链表 (0/6) 
- [x] 栈与队列 (4/7) ⭐️ 已完成核心题目
- [x] 动态规划 (2/15) ⭐️ 今日重点
- [ ] 二叉树 (0/12)
- [ ] 回溯算法 (0/8)
- [ ] 图论 (0/6)
- [ ] 其他 (0/36)

## 📅 每日学习记录

### 第1周

#### Day 1 - 2025/08/03
**今日目标**: 数组双指针基础

**完成题目**:
- [x] 11. 盛最多水的容器 (Medium) - 状态: 🔥 时间: 15min
  - 思路: 双指针 + 贪心，总是移动较矮的指针
  - 难点: 理解为什么移动较高指针无效
  - 代码模板: 双指针对撞模板
  - 延伸题目: 42. 接雨水

- [x] 15. 三数之和 (Medium) - 状态: 🔥 时间: 25min
  - 思路: 排序 + 双指针 + 三层去重
  - 难点: 去重机制的设计和实现
  - 代码模板: 三数之和经典模板
  - 延伸题目: 四数之和、最接近的三数之和

**今日总结**: 
✅ 成功建立C++刷题环境
✅ 掌握双指针基本思想和应用
✅ 学会处理重复元素的去重策略
✅ 理解排序在算法优化中的作用
🎯 双指针已基本掌握，可以进入下个专题

**明日计划**: 继续数组专题或开始滑动窗口 

---

#### Day 2 - 2025/08/04
**今日目标**: 滑动窗口 + 单调队列

**完成题目**:
- [x] 239. 滑动窗口最大值 (Hard) - 状态: 🔥 时间: 30min
  - 思路: 单调双端队列，维护递减序列存储下标
  - 难点: 队列维护策略 - 移除过期元素和保持单调性
  - 代码模板: 单调队列经典模板
  - 延伸题目: 剑指Offer 59-I、1438. 绝对差不超过限制的最长连续子数组

- [x] 155. 最小栈 (Medium) - 状态: 🔥 时间: 20min
  - 思路: 双栈法 - 主栈存所有元素，辅助栈存最小值
  - 难点: 重复最小值处理，需要用<= 而不是<
  - 代码模板: 辅助栈设计模板
  - 延伸题目: 232. 用栈实现队列、225. 用队列实现栈

- [x] 84. 柱状图中最大的矩形 (Hard) - 状态: 🔥 时间: 35min
  - 思路: 单调栈 - 维护递增栈，弹栈时计算面积
  - 难点: 理解弹栈时机和宽度计算，边界处理技巧
  - 代码模板: 单调栈经典模板
  - 延伸题目: 42. 接雨水、85. 最大矩形

- [x] 42. 接雨水 (Hard) - 状态: 🔥 时间: 25min
  - 思路: 单调栈 - 维护递减栈，按层计算雨水
  - 难点: 理解雨水面积计算，宽度和高度的确定
  - 代码模板: 单调栈变种应用
  - 延伸题目: 407. 接雨水II、11. 盛最多水的容器

- [x] 70. 爬楼梯 (Easy) - 状态: 🔥 时间: 30min
  - 思路: 动态规划 - 状态转移方程 dp[i] = dp[i-1] + dp[i-2]
  - 难点: 理解DP四要素，记忆化搜索vs普通递归的区别
  - 代码模板: DP基础模板、记忆化搜索、空间优化
  - 延伸题目: 198. 打家劫舍、509. 斐波那契数列

- [x] 198. 打家劫舍 (Medium) - 状态: 🔥 时间: 35min
  - 思路: 决策类DP - 状态转移方程 dp[i] = max(nums[i]+dp[i-2], dp[i-1])
  - 难点: 理解选择决策，约束条件对状态转移的影响
  - 代码模板: 决策类DP模板、记忆化缓存技巧
  - 延伸题目: 213. 打家劫舍II、337. 打家劫舍III

**今日总结**: 
✅ 掌握单调队列核心思想和实现
✅ 理解滑动窗口最值问题的最优解法
✅ 学会O(n)时间复杂度处理动态最值
✅ 掌握辅助栈设计思想，理解栈的扩展应用
✅ 精通单调栈算法，理解左右边界确定机制
✅ 掌握单调栈在不同场景的灵活应用
✅ 入门动态规划，理解DP四要素和基本思维
✅ 精通决策类DP，掌握选择决策的核心思想
🎯 动态规划基础已扎实，可以挑战更复杂的DP问题

**明日计划**: 继续动态规划专题(53.最大子数组和 或 322.零钱兑换) 

## 🔄 复习计划

### 需要3天后复习 ❌
- [ ] 题目名称 - 日期

### 需要1周后复习 ⚡  
- [ ] 题目名称 - 日期

### 需要1月后复习 🔥
- [ ] 题目名称 - 日期

## 📝 知识点总结

### 算法模板库

#### 双指针
```cpp
// 对撞指针 - 盛最多水的容器
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxArea = 0;
    while (left < right) {
        int currentArea = min(height[left], height[right]) * (right - left);
        maxArea = max(maxArea, currentArea);
        if (height[left] < height[right]) left++;
        else right--;
    }
    return maxArea;
}

// 三数之和 - 排序 + 双指针 + 去重
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> result;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); i++) {
        if (i > 0 && nums[i] == nums[i-1]) continue;  // 去重
        int left = i + 1, right = nums.size() - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                result.push_back({nums[i], nums[left], nums[right]});
                while (left < right && nums[left] == nums[left+1]) left++;
                while (left < right && nums[right] == nums[right-1]) right--;
                left++; right--;
            } else if (sum < 0) left++;
            else right--;
        }
    }
    return result;
}
```

#### 滑动窗口 + 单调队列
```cpp
// 滑动窗口最大值 - 单调队列模板
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    deque<int> dq;  // 存储下标，保持递减顺序
    
    for (int i = 0; i < nums.size(); i++) {
        // 移除过期元素（超出窗口范围）
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // 维护单调性（移除所有比当前元素小的元素）
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);  // 添加当前元素下标
        
        // 当窗口满时，队首就是最大值
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}

// 通用滑动窗口模板
def sliding_window(s):
    left = 0
    result = 0
    for right in range(len(s)):
        # 扩大窗口
        # 收缩窗口
        while condition:
            left += 1
        # 更新结果
        result = max(result, right - left + 1)
```

#### 链表操作
```python
# 链表反转
def reverse_list(head):
    prev, curr = None, head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

### 易错点记录
1. **边界条件处理**
   - 空数组/空链表
   - 单元素情况
   - 数组越界

2. **算法实现细节**
   - 循环条件 (< vs <=)
   - 指针更新顺序
   - 返回值处理

3. **今日易错点**
   - **双指针移动策略**: 记住总是移动较矮/较小的指针
   - **去重处理**: 三数之和需要三层去重，容易遗漏
   - **边界检查**: while循环中的`left < right`条件很重要

## 🎯 阶段性目标

### 第1-2周目标
- [ ] 完成数组双指针专题 (10题)
- [ ] 掌握基础滑动窗口模板
- [ ] 熟练链表基本操作

### 第3-4周目标  
- [ ] 完成栈队列专题 (7题)
- [ ] 掌握单调栈模板
- [ ] 开始动态规划入门

### 第5-6周目标
- [ ] 完成树和回溯专题 (20题) 
- [ ] 建立完整的算法知识框架
- [ ] 达到70%题目熟练掌握

## 💡 学习心得

### 本周收获 (Day 1)
- 学到的新技巧: 双指针对撞模式、三层去重策略、排序辅助算法优化
- 理解深刻的题目: 15. 三数之和 - 将O(n³)优化到O(n²)的经典案例
- 需要加强的地方: 去重逻辑的细节处理，需要多练习类似题目

### 优化建议
- 时间管理:
- 学习方法:
- 复习策略:

---

## 使用说明

1. **每日更新**: 完成题目后立即更新状态和笔记
2. **状态含义**: 
   - 🔥 熟练掌握 (10分钟内独立AC)
   - ⚡ 基本理解 (需要提示但能完成)  
   - ❌ 需要复习 (无法独立完成)
3. **复习提醒**: 根据遗忘曲线安排复习时间
4. **模板积累**: 及时总结代码模板和解题套路
5. **定期回顾**: 每周总结学习效果，调整计划